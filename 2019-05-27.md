

### Algorithm

两只青蛙在网上相识了，它们聊得很开心，于是觉得很有必要见一面。它们很高兴地发现它们住在同一条纬度线上，于是它们约定各自朝西跳，直到碰面为止。可是它们出发之前忘记了一件很重要的事情，既没有问清楚对方的特征，也没有约定见面的具体位置。不过青蛙们都是很乐观的，它们觉得只要一直朝着某个方向跳下去，总能碰到对方的。但是除非这两只青蛙在同一时间跳到同一点上，不然是永远都不可能碰面的。为了帮助这两只乐观的青蛙，你被要求写一个程序来判断这两只青蛙是否能够碰面，会在什么时候碰面。
我们把这两只青蛙分别叫做青蛙A和青蛙B，并且规定纬度线上东经0度处为原点，由东往西为正方向，单位长度1米，这样我们就得到了一条首尾相接的数轴。设青蛙A的出发点坐标是x，青蛙B的出发点坐标是y。青蛙A一次能跳m米，青蛙B一次能跳n米，两只青蛙跳一次所花费的时间相同。纬度线总长L米。现在要你求出它们跳了几次以后才会碰面。

Input

    输入只包括一行5个整数x，y，m，n，L，其中x≠y < 2000000000，0 < m、n < 2000000000，0 < L < 2100000000。

Output

    输出碰面所需要的跳跃次数，如果永远不可能碰面则输出一行"Impossible"

Sample Input

1 2 3 4 5

Sample Output

4

分析:

x + m*t - (y + n*t) = k*L

求满足条件的 t 和 k

这里假定 x + m*t > y + n*t

x - y + (m - n) * t = k*L

x - y - (n - m) * t = k*L

x - y = (n - m) * t + k*L

令:

x - y = c
n-m = a
L = b
t = x
k = y

c = a*x + b*y

问题化为

已知：a,b,c 求 a*x + b*y = c 的正整数解 x,y

这是典型的线性同余方程

令 a,b 的最大公约数是 d，那么

a/d * x + b/d * y = c/d

由于 x, y, a/d, b/d 都是整数，所以 c/d  必须为整数，否则无解

如果 a*x0 + b*y0 = d 有解，那么

a*c/d*x0 + b*c/d*y0 = c

于是

a*x + b*y = c 有解

x = c/d*x0
y = c/d*y0

下面就是求解 a*x0 + b*y0 = d 是否有解的问题

扩展欧几里德算法

基本算法：对于不完全为 0 的非负整数 a,b，gcd(a，b) 表示 a,b 的最大公约数，必然存在整数对 x,y 使得 gcd（a，b）=ax+by。

于是，由扩展欧几里德算法知道 a*x0 + b*y0 = d 有解

证明：设 a>b。

1，显然当 b=0，gcd(a,b)=a。此时 x=1，y=0；
2，a*b!=0 时

设

    ax1+by1=gcd(a,b);
    bx2+(a mod b)y2=gcd(b,a mod b);

根据朴素的欧几里德原理有 gcd(a,b)=gcd(b,a mod b);

    a*x1+b*y1=b*x2+(a mod b)y2;
    a*x1+b*y1=b*x2+(a-(a/b)*b)*y2=a*y2+b(x2-(a/b)*y2);

根据恒等定理得：

    x1=y2
    y1=x2-(a/b)*y2

这样我们就得到了求解 x1,y1 的方法：x1，y1 的值基于 x2，y2.

上面的思想是以递归定义的，因为 gcd 不断的递归求解一定会有个时候 b=0，所以递归可以结束。

```java
class Solution {
    int x;
    int y;
}

int gcd(a, b, Solution s)
{
    if (b == 0) {
        s.x = 1;
        s.y = 0;
        return a;
    }
    int d = gcd(b, a%b, s);
    s.x = s.y;
    s.y = s.x - a/b*s.y;
    return d;
}

public find(x, y, m, n)
{
    int d = gcd(n-m, L, x, y);
    r = L/d;
    if ((x-y)%d != 0)
    {
        System.out.println("Impossible");
    }
    else
    {
        System.out.println( ((x-y) / d * X % r + r) % r);
    }
}

public static void main(String [])
{
    find(x, y, m, n, X, Y)
}


```


### Review

Effective 61 throw exception appropriate to abstraction

### Tips

在1949 年中国电话普及率为 0.05%，即便是 1990 年，固定电话普及率也仅仅
为 1.1%，紧接着十年间，这个数字就将飞速提高到 50%。

现在的 BlockChain 和 AI 处于哪个阶段呢？

### Share

最近在关注币圈的走势，最大感受就是投资是反人性的，人在遇到价格增长时，
生怕错过，会去追涨。但是，当下跌的时候，由于风险的考虑，会杀跌。对于
做过任何投资的人来说，这是个非常简单的道理。但是，这个可以放到任何领域，
因为这是人性，因此在很多领域都有体现。比如技术领域，很多人都喜欢跟时髦，被各种媒体影响。
